{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/dfs.js","algorithms/sid.js","algorithms/bestfs.js","algorithms/astar.js","PathFindingVisualizer/PathFindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","visitedNodesinorder","flag","bestfs","heuristic","x","y","i","astar","a","b","PathFindingVisualizer","state","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","isModalOpen","mouseIsPressed","vset","Set","hset","flagForDfs","toggleModal","bind","handleLogin","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","setTimeout","animateShortestPath","document","getElementById","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","nodesinOrder","animateShortestPathdfs","dfs","str","stc","fr","fc","parent","console","log","getNodesDfsPathOrder","animateDfs","visitedNodes","sidAlgo","loopbreaker","Math","floor","random","animateSid","tmparray","j","nodesInBestPathOrder","getNodesInBestPathOrder","nodesInastarPathOrder","getNodesInastarPathOrder","sx","sy","ex","ey","xdist","ydist","has","hole","nset","add","xset","getNewGridWithHole","recursive_division","nset2","yset","event","startnoderow","value","startnodecol","endnoderow","endnodecol","preventDefault","Breadcrumb","ButtonGroup","Button","onClick","visualizeDijkstra","visualizeDFS","visualizeastar","visualizeBestFS","visualizeSidAlgo","gardient","generateMaze","outline","Modal","isOpen","toggle","ModalHeader","ModalBody","Form","onSubmit","FormGroup","Label","htmlFor","Input","type","name","placeholder","innerRef","input","color","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cf1f0c44.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","const visitedNodesinorder = [];\r\nlet flag = true;\r\nexport function dfs(grid, str, stc, fr, fc, parent) {\r\n  if (\r\n    str >= 0 &&\r\n    stc >= 0 &&\r\n    str < 20 &&\r\n    stc < 50 &&\r\n    fr >= 0 &&\r\n    fr < 20 &&\r\n    fc >= 0 &&\r\n    fc < 50 &&\r\n    flag === true\r\n  ) {\r\n    if (str === fr && stc === fc) {\r\n      visitedNodesinorder.push(grid[fr][fc]);\r\n      grid[str][stc].previousNode = parent;\r\n      flag = false;\r\n      console.log(\"found finish node\\n\");\r\n      //console.log(grid[fr][fc]);\r\n    }\r\n    if (\r\n      grid[str][stc].isVisited === false &&\r\n      grid[str][stc].isWall === false &&\r\n      flag === true\r\n    ) {\r\n      grid[str][stc].isVisited = true;\r\n      grid[str][stc].previousNode = parent;\r\n      //console.log(grid[str][stc]);\r\n\r\n      visitedNodesinorder.push(grid[str][stc]);\r\n      dfs(grid, str, stc + 1, fr, fc, grid[str][stc]);\r\n      dfs(grid, str, stc - 1, fr, fc, grid[str][stc]);\r\n      dfs(grid, str + 1, stc, fr, fc, grid[str][stc]);\r\n      dfs(grid, str - 1, stc, fr, fc, grid[str][stc]);\r\n    }\r\n  }\r\n}\r\nexport function getdfsnodes() {\r\n  return visitedNodesinorder;\r\n}\r\n// Backtracks from the finishNode to find the shortest path.\r\n//  Only works when called *after* the dfs method above.\r\nexport function getNodesDfsPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","const visitedNodesinorder = [];\r\nlet flag = true;\r\nexport function sidAlgo(grid, str, stc, fr, fc, parent) {\r\n  if (\r\n    str >= 0 &&\r\n    stc >= 0 &&\r\n    str < 20 &&\r\n    stc < 50 &&\r\n    fr >= 0 &&\r\n    fr < 20 &&\r\n    fc >= 0 &&\r\n    fc < 50 &&\r\n    flag === true\r\n  ) {\r\n    if (str === fr && stc === fc) {\r\n      visitedNodesinorder.push(grid[fr][fc]);\r\n      grid[str][stc].previousNode = parent;\r\n      flag = false;\r\n      console.log(\"found finish node\");\r\n    }\r\n    if (\r\n      grid[str][stc].isVisited === false &&\r\n      grid[str][stc].isWall === false &&\r\n      flag === true\r\n    ) {\r\n      grid[str][stc].isVisited = true;\r\n      grid[str][stc].previousNode = parent;\r\n      visitedNodesinorder.push(grid[str][stc]);\r\n      if (\r\n        str < fr &&\r\n        grid[str + 1][stc].isWall === false &&\r\n        grid[str + 1][stc].isVisited === false\r\n      ) {\r\n        sidAlgo(grid, str + 1, stc, fr, fc, grid[str][stc]);\r\n      } else if (\r\n        str > fr &&\r\n        grid[str - 1][stc].isWall === false &&\r\n        grid[str - 1][stc].isVisited === false\r\n      ) {\r\n        sidAlgo(grid, str - 1, stc, fr, fc, grid[str][stc]);\r\n      } else if (\r\n        stc < fc &&\r\n        grid[str][stc + 1].isWall === false &&\r\n        grid[str][stc + 1].isVisited === false\r\n      ) {\r\n        sidAlgo(grid, str, stc + 1, fr, fc, grid[str][stc]);\r\n      } else if (\r\n        stc > fc &&\r\n        grid[str][stc - 1].isWall === false &&\r\n        grid[str][stc - 1].isVisited === false\r\n      ) {\r\n        sidAlgo(grid, str, stc - 1, fr, fc, grid[str][stc]);\r\n      } else {\r\n        console.log(\"exception\");\r\n\r\n        let loopbreaker = true;\r\n        var x;\r\n        while (loopbreaker) {\r\n          x = Math.floor(Math.random() * 4 + 1);\r\n          if (\r\n            x === 1 &&\r\n            grid[str + 1][stc].isWall === false &&\r\n            grid[str + 1][stc].isVisited === false\r\n          ) {\r\n            loopbreaker = false;\r\n          } else if (\r\n            x === 2 &&\r\n            grid[str - 1][stc].isWall === false &&\r\n            grid[str - 1][stc].isVisited === false\r\n          ) {\r\n            loopbreaker = false;\r\n          } else if (\r\n            x === 3 &&\r\n            grid[str][stc + 1].isWall === false &&\r\n            grid[str][stc + 1].isVisited === false\r\n          ) {\r\n            loopbreaker = false;\r\n          } else if (\r\n            x === 4 &&\r\n            grid[str][stc - 1].isWall === false &&\r\n            grid[str][stc - 1].isVisited === false\r\n          ) {\r\n            loopbreaker = false;\r\n          }\r\n        }\r\n        if (x === 1) {\r\n          sidAlgo(grid, str + 1, stc, fr, fc, grid[str][stc]);\r\n        } else if (x === 2) {\r\n          sidAlgo(grid, str - 1, stc, fr, fc, grid[str][stc]);\r\n        } else if (x === 3) {\r\n          sidAlgo(grid, str, stc + 1, fr, fc, grid[str][stc]);\r\n        } else {\r\n          sidAlgo(grid, str, stc - 1, fr, fc, grid[str][stc]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getsidnodes() {\r\n  return visitedNodesinorder;\r\n}\r\n","// Performs best first search algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, optimally allowing us to compute the optimal path(may not be shortest)\r\n// by backtracking from the finish node.\r\nexport function bestfs(grid, startNode, finishNode, heuristic) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, heuristic);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, heuristic) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  //   for (const neighbor of unvisitedNeighbors) {\r\n  //     neighbor.distance = node.distance + 1;\r\n  //     neighbor.previousNode = node;\r\n  //   }\r\n  unvisitedNeighbors.sort(\r\n    (x, y) => heuristic[x.row][x.col] > heuristic[y.row][y.col]\r\n  );\r\n  for (let i = 1; i <= unvisitedNeighbors.length; ++i) {\r\n    if (i === 1) unvisitedNeighbors[i - 1].distance = node.distance + i;\r\n    else unvisitedNeighbors[i - 1].distance = node.distance + i * 1000;\r\n    unvisitedNeighbors[i - 1].previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(\r\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\r\n  );\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInBestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// Performs astar search algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, optimally allowing us to compute the optimal path(may not be shortest)\r\n// by backtracking from the finish node.\r\nexport function astar(grid, startNode, finishNode, heuristic) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  let flag = true;\r\n  let i = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length && flag) {\r\n    sortNodesByDistance(unvisitedNodes, heuristic);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) {\r\n      flag = false;\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n    i = i + 1;\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes, heuristic) {\r\n  unvisitedNodes.sort(\r\n    (a, b) =>\r\n      a.distance +\r\n      heuristic[a.row][a.col] -\r\n      (b.distance + heuristic[b.row][b.col])\r\n  );\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (let i = 1; i <= unvisitedNeighbors.length; ++i) {\r\n    unvisitedNeighbors[i - 1].distance = node.distance + 1;\r\n    unvisitedNeighbors[i - 1].previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(\r\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\r\n  );\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInastarPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component, Fragment } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathFindingVisualizer.css\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport { dfs, getNodesDfsPathOrder, getdfsnodes } from \"../algorithms/dfs\";\r\nimport { sidAlgo, getsidnodes } from \"../algorithms/sid\";\r\nimport { bestfs, getNodesInBestPathOrder } from \"../algorithms/bestfs\";\r\nimport { astar, getNodesInastarPathOrder } from \"../algorithms/astar\";\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\nimport { Button, ButtonGroup, Breadcrumb, Modal, ModalHeader, ModalBody, FormGroup, Form, Input, Label } from 'reactstrap';\r\nimport '@fortawesome/fontawesome-free/css/all.min.css';\r\nimport 'bootstrap-css-only/css/bootstrap.min.css';\r\nimport 'mdbreact/dist/css/mdb.css';\r\nimport { MDBBtn } from \"mdbreact\";\r\n\r\n\r\n\r\nexport class PathFindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      START_NODE_ROW: 5,\r\n      START_NODE_COL: 7,\r\n      FINISH_NODE_ROW: 16,\r\n      FINISH_NODE_COL: 44,\r\n      isModalOpen: false,\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      vset: new Set(),\r\n      hset: new Set(),\r\n      flagForDfs: false,\r\n    };\r\n    this.toggleModal = this.toggleModal.bind(this);\r\n    this.handleLogin = this.handleLogin.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(\r\n      this.state.START_NODE_ROW,\r\n      this.state.START_NODE_COL,\r\n      this.state.FINISH_NODE_ROW,\r\n      this.state.FINISH_NODE_COL);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n    const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  animateDfs(visitedNodesInOrder, nodesinOrder) {\r\n    for (let i = 0; i < visitedNodesInOrder.length; ++i) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.animateShortestPathdfs(nodesinOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n\r\n    }\r\n  }\r\n  animateShortestPathdfs(nodesinOrder) {\r\n    for (let i = 0; i < nodesinOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesinOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 20 * i);\r\n    }\r\n  }\r\n  visualizeDFS() {\r\n    const { grid } = this.state;\r\n    dfs(\r\n      grid,\r\n      this.state.START_NODE_ROW,\r\n      this.state.START_NODE_COL,\r\n      this.state.FINISH_NODE_ROW,\r\n      this.state.FINISH_NODE_COL,\r\n      null\r\n    );\r\n    const visitedNodesInOrder = getdfsnodes();\r\n    console.log(visitedNodesInOrder);\r\n    const nodesinOrder = getNodesDfsPathOrder(\r\n      grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL]\r\n    );\r\n    console.log(nodesinOrder);\r\n    this.animateDfs(visitedNodesInOrder, nodesinOrder);\r\n  }\r\n  animateSid(visitedNodes) {\r\n    for (let i = 0; i < visitedNodes.length; ++i) {\r\n      setTimeout(() => {\r\n        const node = visitedNodes[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 20 * i);\r\n    }\r\n  }\r\n  visualizeSidAlgo() {\r\n    const { grid } = this.state;\r\n    sidAlgo(\r\n      grid,\r\n      this.state.START_NODE_ROW,\r\n      this.state.START_NODE_COL,\r\n      this.state.FINISH_NODE_ROW,\r\n      this.state.FINISH_NODE_COL,\r\n      null\r\n    );\r\n    const visitedNodes = getsidnodes();\r\n    console.log(visitedNodes);\r\n    this.animateSid(visitedNodes);\r\n  }\r\n  visualizeBestFS() {\r\n    const heuristic = [];\r\n    for (let i = 0; i < 20; ++i) {\r\n      const tmparray = [];\r\n      for (let j = 0; j < 50; ++j) {\r\n        tmparray[j] =\r\n          (i - this.state.FINISH_NODE_ROW) * (i - this.state.FINISH_NODE_ROW) +\r\n          (j - this.state.FINISH_NODE_COL) * (j - this.state.FINISH_NODE_COL);\r\n      }\r\n      heuristic.push(tmparray);\r\n    }\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n    const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bestfs(grid, startNode, finishNode, heuristic);\r\n    const nodesInBestPathOrder = getNodesInBestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInBestPathOrder);\r\n  }\r\n\r\n  visualizeastar() {\r\n    const heuristic = [];\r\n    for (let i = 0; i < 20; ++i) {\r\n      const tmparray = [];\r\n      for (let j = 0; j < 50; ++j) {\r\n        tmparray[j] =\r\n          (i - this.state.FINISH_NODE_ROW) * (i - this.state.FINISH_NODE_ROW) +\r\n          (j - this.state.FINISH_NODE_COL) * (j - this.state.FINISH_NODE_COL);\r\n      }\r\n      heuristic.push(tmparray);\r\n    }\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n    const finishNode = grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n    const visitedNodesInOrder = astar(grid, startNode, finishNode, heuristic);\r\n    const nodesInastarPathOrder = getNodesInastarPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInastarPathOrder);\r\n  }\r\n\r\n  recursive_division(sx, sy, ex, ey) {\r\n    //console.log(\"inside recursive division\");\r\n\r\n    let xdist = ex - sx;\r\n    let ydist = ey - sy;\r\n    if (xdist < 2 || ydist < 2)\r\n      return;\r\n    else if ((xdist >= 2 && ydist < 2) || xdist > ydist) {\r\n      let x = Math.floor(Math.random() * (ex - sx - 1)) + sx + 1;\r\n      let count = 0;\r\n      // while (this.state.vset.has(x) === true) {\r\n      //   if (xdist === 2 || count > 10)\r\n      //     return;\r\n      //   console.log(\"bancho1\");\r\n      //   count++;\r\n      //   x = Math.floor(Math.random() * (ex - sx - 1)) + sx + 1;\r\n      // }\r\n      if (this.state.hset.has(x) === true)\r\n        return;\r\n      for (let i = sy; i <= ey; ++i) {\r\n\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, x, i);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n      }\r\n      let hole = Math.floor(Math.random() * (ydist + 1) + sy);\r\n      let nset = this.state.vset;\r\n      nset.add(hole);\r\n      let xset = this.state.hset;\r\n      xset.add(x);\r\n      this.setState({\r\n        vset: nset,\r\n        hset: xset,\r\n      });\r\n      const newGrid = getNewGridWithHole(this.state.grid, x, hole);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n      this.recursive_division(sx, sy, x - 1, ey);\r\n      this.recursive_division(x + 1, sy, ex, ey);\r\n\r\n    }\r\n    else if ((ydist >= 2 && xdist < 2) || ydist > xdist) {\r\n      let x = Math.floor(Math.random() * (ey - sy - 1)) + sy + 1;\r\n      let count2 = 0;\r\n      // while (this.state.hset.has(x) === true) {\r\n      //   if (ydist === 2 || count2 > 10)\r\n      //     return;\r\n      //   console.log(\"bancho2\");\r\n      //   count2++;\r\n      //   x = Math.floor(Math.random() * (ey - sy - 1)) + sy + 1;\r\n      // }\r\n      if (this.state.vset.has(x) === true)\r\n        return;\r\n      for (let i = sx; i <= ex; ++i) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, i, x);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n      }\r\n      let hole = Math.floor(Math.random() * (xdist + 1) + sx);\r\n      let nset2 = this.state.hset;\r\n      nset2.add(hole);\r\n      let yset = this.state.vset;\r\n      yset.add(x);\r\n      this.setState({\r\n        hset: nset2,\r\n        vset: yset,\r\n      });\r\n      const newGrid = getNewGridWithHole(this.state.grid, hole, x);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n      this.recursive_division(sx, sy, ex, x - 1);\r\n      this.recursive_division(sx, x + 1, ex, ey);\r\n\r\n    }\r\n\r\n  }\r\n  generateMaze() {\r\n\r\n    for (let i = 0; i < 20; ++i) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, i, 0);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n    for (let i = 0; i < 20; ++i) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, i, 49);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n    for (let i = 1; i < 49; ++i) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, 0, i);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n    for (let i = 1; i < 49; ++i) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, 19, i);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n    this.recursive_division(1, 1, 18, 48);\r\n\r\n\r\n\r\n  }\r\n  toggleModal() {\r\n    this.setState({\r\n      isModalOpen: !this.state.isModalOpen\r\n    })\r\n\r\n  }\r\n\r\n  handleLogin(event) {\r\n    this.toggleModal();\r\n    // alert(\"startnoderow: \" + this.startnoderow.value + \" startnodercol: \" + this.startnodecol.value\r\n    //   + \" endnoderow: \" + this.endnoderow.value + \" endnodercol: \" + this.endnodecol.value);\r\n\r\n    let sx = this.state.START_NODE_ROW;\r\n    let sy = this.state.START_NODE_COL;\r\n    let ex = this.state.FINISH_NODE_ROW;\r\n    let ey = this.state.FINISH_NODE_COL;\r\n    document.getElementById(`node-${sx}-${sy}`).className =\r\n      \"node\";\r\n    const { grid } = this.state;\r\n    grid[sx][sy].isStart = false;\r\n    document.getElementById(`node-${ex}-${ey}`).className =\r\n      \"node\";\r\n    grid[ex][ey].isFinish = false;\r\n\r\n    //creating new start and end nodes\r\n    this.setState({\r\n      START_NODE_ROW: this.startnoderow.value,\r\n      START_NODE_COL: this.startnodecol.value,\r\n      FINISH_NODE_ROW: this.endnoderow.value,\r\n      FINISH_NODE_COL: this.endnodecol.value,\r\n    });\r\n\r\n    document.getElementById(`node-${this.startnoderow.value}-${this.startnodecol.value}`).className =\r\n      \"node node-start\";\r\n    grid[this.startnoderow.value][this.startnodecol.value].isStart = false;\r\n    document.getElementById(`node-${this.endnoderow.value}-${this.endnodecol.value}`).className =\r\n      \"node node-finish\";\r\n    grid[this.endnoderow.value][this.endnodecol.value].isStart = false;\r\n\r\n\r\n    event.preventDefault();\r\n\r\n  }\r\n\r\n  render() {\r\n\r\n    const { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n\r\n      <Fragment>\r\n        <Breadcrumb>\r\n          <ButtonGroup className=\"ml-0\">\r\n            <Button className=\"btn btn-sm bg-primary\" onClick={() => this.visualizeDijkstra()}>\r\n              Visualize Dijkstra's Algorithm\r\n          </Button>\r\n            <Button className=\"btn btn-sm bg-secondary\" onClick={() => this.visualizeDFS()}>\r\n              Visualize DFS Algorithm\r\n          </Button>\r\n            <Button className=\"btn btn-sm bg-success\" onClick={() => this.visualizeastar()}>\r\n              A Star\r\n          </Button>\r\n            <Button className=\"btn btn-sm bg-danger\" onClick={() => this.visualizeBestFS()}>\r\n              Best First Search\r\n          </Button>\r\n            <Button className=\"btn btn-sm bg-info\" onClick={() => this.visualizeSidAlgo()}>\r\n              Visualize Siddhartha's Algorithm\r\n          </Button>\r\n          </ButtonGroup>\r\n          <MDBBtn gardient=\"aqua\" onClick={() => this.generateMaze()}>\r\n            Generate Maze\r\n          </MDBBtn>\r\n          <Button outline onClick={this.toggleModal}>\r\n            <span className=\"fa fa-sign-in fa-lg\"></span> Set Nodes\r\n          </Button>\r\n        </Breadcrumb>\r\n        <Modal isOpen={this.state.isModalOpen} toggle={this.toggleModal}>\r\n          <ModalHeader toggle={this.toggleModal}>Set Nodes</ModalHeader>\r\n          <ModalBody>\r\n            <Form onSubmit={this.handleLogin}>\r\n              <FormGroup>\r\n                <Label htmlFor=\"startnoderow\">Start Node Row</Label>\r\n                <Input type=\"number\" id=\"startnoderow\" name=\"startnoderow\" placeholder=\"Between 1-18\"\r\n                  innerRef={(input) => this.startnoderow = input}></Input>\r\n              </FormGroup>\r\n              <FormGroup>\r\n                <Label htmlFor=\"startnodecol\">Start Node Col</Label>\r\n                <Input type=\"number\" id=\"startnodecol\" name=\"startnodecol\" placeholder=\"Between 1-48\"\r\n                  innerRef={(input) => this.startnodecol = input}></Input>\r\n              </FormGroup>\r\n              <FormGroup>\r\n                <Label htmlFor=\"endnoderow\">End Node Row</Label>\r\n                <Input type=\"number\" id=\"endnoderow\" name=\"endnoderow\" placeholder=\"Between 1-18\"\r\n                  innerRef={(input) => this.endnoderow = input}></Input>\r\n              </FormGroup>\r\n              <FormGroup>\r\n                <Label htmlFor=\"endnodecol\">End Node Col</Label>\r\n                <Input type=\"number\" id=\"endnodecol\" name=\"endnodecol\" placeholder=\"Between 1-48\"\r\n                  innerRef={(input) => this.endnodecol = input}></Input>\r\n              </FormGroup>\r\n              <Button type=\"submit\" value=\"submit\" color=\"primary\">Set Nodes</Button>\r\n            </Form>\r\n          </ModalBody>\r\n        </Modal>\r\n        <div className=\"gird\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    isVisited,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      isVisited={isVisited}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (sx, sy, ex, ey) => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row, sx, sy, ex, ey));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\nconst createNode = (col, row, sx, sy, ex, ey) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === sx && col === sy,\r\n    isFinish: row === ex && col === ey,\r\n    distance: 10000,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithHole = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: false,\r\n  }\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n}\r\n\r\nexport default PathFindingVisualizer;\r\n\r\n","import React from 'react';\nimport PathFindingVisualizer from \"./PathFindingVisualizer/PathFindingVisualizer\"\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer></PathFindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}